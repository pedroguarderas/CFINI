# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Diffusion solver with implicit Euler scheme
#' @description Solver for diffusion problems implemented using the Euler implicit scheme
#' @param alpha matrix discretization Diffusion parameter
#' @param u0 vector with discretization of the initial condition
#' @param u1 vector with discretization of the inferior boundary condition
#' @param u2 vector with discretization of the superior boundary condition
#' @param t vector with discretization of the time grid
#' @param x vector with discretization of the spatial grid
#' @return List with solution parameters
#' @note Diffusion solver for pricing options
#' @author Pedro Guarderas
#' @export
cf_diff_solv_euls <- function(alpha, u0, u1, u2, t, x, is_initial) {
    .Call(`_CFINI_cf_diff_solv_euls`, alpha, u0, u1, u2, t, x, is_initial)
}

#' @title Diffusion solver with Crank-Nicolson scheme
#' @description Solver for diffusion problems implemented with Crank-Nicolson scheme
#' @param theta Parameter for the Crank-Nicolson scheme
#' @param alpha matrix discretization Diffusion parameter
#' @param u0 vector with discretization of the initial condition
#' @param u1 vector with discretization of the inferior boundary condition
#' @param u2 vector with discretization of the superior boundary condition
#' @param t vector with discretization of the time grid
#' @param x vector with discretization of the spatial grid
#' @return List with solution parameters
#' @note Diffusion solver for pricing options
#' @author Pedro Guarderas
#' @export
cf_diff_solv_cns <- function(theta, alpha, u0, u1, u2, t, x, is_initial) {
    .Call(`_CFINI_cf_diff_solv_cns`, theta, alpha, u0, u1, u2, t, x, is_initial)
}

#' @title Black-Scholes solver
#' @description Solver for Black-Scholes models implemented with the Crank-Nicolson numerical 
#' scheme
#' @param sigma Volatility
#' @param rate Interest rate
#' @param theta Parameter for the Crank-Nicolson scheme
#' @param u0 vector with discretization of the initial condition
#' @param u1 vector with discretization of the inferior boundary condition
#' @param u2 vector with discretization of the superior boundary condition
#' @param t vector with discretization of the time grid
#' @param x vector with discretization of the spatial grid
#' @return List with solution parameters
#' @note pricing options
#' @author Pedro Guarderas
#' @export
cf_black_scholes_solv_cns <- function(sigma, rate, theta, u0, u1, u2, t, x) {
    .Call(`_CFINI_cf_black_scholes_solv_cns`, sigma, rate, theta, u0, u1, u2, t, x)
}

#' @title Uniform grid
#' @description simple function for grid generation
#' @param a inferior value for the grid
#' @param b superior value for the grid
#' @param n number of points in the grid
#' @return A vector with the grid points.
#' @author Pedro Guarderas
#' @export
cf_uniform_grid <- function(a, b, N) {
    .Call(`_CFINI_cf_uniform_grid`, a, b, N)
}

#' @title Exponential grid
#' @description Adaptive grid generator
#' @param l adaptation points
#' @param a inferior value for the grid
#' @param b superior value for the grid
#' @param n number of points in the grid
#' @param E refinement parameter
#' @return A vector with the adaptive grid points.
#' @author Pedro Guarderas
#' @export
cf_adapt_grid <- function(l, a, b, N, E) {
    .Call(`_CFINI_cf_adapt_grid`, l, a, b, N, E)
}

#' @title Ordinary differenatial equation solver
#' @description Solver for ordinary differential equations, implemented with the predictor 
#' corrector method.
#' @param t time grid, could be adapted
#' @param v0 initial value
#' @param f dynamic function
#' @return Return the numerical solution to the ODE.
#' @note The solver is implemented to compute the solution forwards in time.
#' @author Pedro Guarderas
#' @export
cf_edo_solv_precor <- function(t, v0, f, m = 2L, err = 1e-2) {
    .Call(`_CFINI_cf_edo_solv_precor`, t, v0, f, m, err)
}

#' @title Tridiagonal solver
#' @description Solver tridiagonal matrices.
#' @param a lower diagonal
#' @param b diagonal
#' @param c upper diagonal
#' @param d image of the solution vector, which over written with the solution
#' @author Pedro Guarderas
#' @export
cf_tri_diag_solv <- function(a, b, c, d) {
    invisible(.Call(`_CFINI_cf_tri_diag_solv`, a, b, c, d))
}

#' @title PSOR algorithm
#' @description Projected successive over-relaxation
#' @param u0 initial guest of the solution
#' @param A matrix determining the variational inequality
#' @param b right term of the inequality
#' @param c lower constraint for the solution
#' @param w weight
#' @param n maximal number of iterations
#' @param e relative error for the solution improvement
#' @author Pedro Guarderas
#' @export
cf_psor_solv <- function(u0, A, b, c, w, n, e) {
    .Call(`_CFINI_cf_psor_solv`, u0, A, b, c, w, n, e)
}

#' @title Brownian motion
#' @description Simulate d-dimensional Browninan motion
#' @param d Dimension
#' @param t Time grid
#' @return List with solution parameters
#' @note Diffusion solver for pricing options
#' @author Pedro Guarderas
#' @useDynLib CFINI, .registration = TRUE
#' @importFrom Rcpp sourceCpp
#' @export
cf_wiener <- function(d, t) {
    .Call(`_CFINI_cf_wiener`, d, t)
}

